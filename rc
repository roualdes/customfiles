#!/usr/bin/env bb

(require '[clojure.java.shell :refer [sh]]
         '[clojure.tools.cli :refer [parse-opts]]
         '[clojure.string :as string]
         '[clojure.java.io :as io]
         '[clojure.pprint :refer [pprint]])

(def cli-options
  [["-n" "--dry-run" "Do a dry run before living dangerously"]
   ["-t" "--test" "Test script by echoing the command that would otherwise be run"]
   ["-h" "--help"]])

(defn usage [options-summary]
  (->> ["Push (sync) (local -> remote) or pull (copy) (remote -> local) files or (sub-)folders"
        "within ~/dos, which itself is referenced as . no matter what pwd says."
        ""
        "Subfolders and file of ~/dos are referenced by path relative to ~/dos"
        "e.g. research/mcbayes or website/update.sh"
        ""
        "Usage: rc [options] action path"
        ""
        "The following example will dry run pull the contents of"
        "website from local to remote deleting from remote what does not "
        "exist on local."
        ""
        "Example: rc -n push website"
        ""
        "Options:"
        options-summary
        ""
        "Actions:"
        "  push    Push to DigitalOcean storage (deletes files on remote)"
        "  pull    Pull from DigitalOcean storage (never deletes files)"
        ""]
       (string/join \newline)))

(defn error-msg [errors]
  (str "The following errors occurred while parsing your command:\n\n"
       (string/join \newline errors)))

(defn not-dot [path]
  (if (string/includes? path ".") "" path))

(defn folder? [path]
  (if (string/includes? path ".")
    (empty? (string/split path #"\."))
    true))

(defn local [valargs]
  (let [{:keys [action path]} valargs
        home (System/getProperty "user.home")
        file (str home "/dos/" path)]
    (str home "/dos/"
         (if (folder? file)
           (not-dot path)
           (if (= action "push")
             path
             (if (string/includes? path "/")
               (str (string/join "/" (butlast (string/split path #"/"))) "/")))))))

(defn add-local [valargs]
  (assoc valargs :command
         (conj (:command valargs)
               (local valargs))))

(defn remote [valargs]
  (let [{:keys [action path]} valargs
        home (System/getProperty "user.home")
        file (str home "/dos/" path)]
    (str "dos:roualdes/"
         (if (folder? file)
           (not-dot path)
           (if (= action "pull")
             path
             (if (string/includes? path "/")
               (str (string/join "/" (butlast (string/split path #"/"))) "/")))))))

(defn add-remote [valargs]
  (assoc valargs :command
         (conj (:command valargs)
               (remote valargs))))

(defn validate-args
  "Validate command line arguments. Either return a map indicating the program
  should exit (with an error message, and optional ok status), or a map
  indicating the action the program should take and the options provided."
  [args]
  (let [{:keys [options arguments errors summary]} (parse-opts args cli-options)
        action (first arguments)
        path (second arguments)]
    (cond
      (:help options) ; help => exit OK with usage summary
      {:exit-message (usage summary) :ok? true}
      errors ; errors => exit with description of errors
      {:exit-message (error-msg errors)}
      (let [action action
            path path
            home (System/getProperty "user.home")]
        (and (= 2 (count arguments))
             (#{"push" "pull"} action)))
      ;; TODO? add check exixts? local or remote
      ;; (.exists (io/as-file (str home "/dos/" path)))
      {:action action :path path :command ["rclone"] :options options}
      :else ; failed  custom validation => exit with usage summary
      {:exit-message (usage summary)})))

(defn exit [status msg]
  (println msg)
  (System/exit status))

(defn add-action [valargs]
  (let [action (:action valargs)
        rc-cmd ((keyword action) {:push "sync" :pull "copy"})]
    (assoc valargs :command
           (conj (:command valargs) rc-cmd))))

(defn test-flag [valargs]
  (if (:test (:options valargs))
    (assoc valargs :command
           (vec (cons "echo" (:command valargs))))
    valargs))

(defn push-flags [valargs]
  (assoc valargs :command
         (conj (:command valargs)
               "--exclude=node_modules/**"
               "--exclude=.DS_Store"
               "--exclude=.p.kdbx.lock"
               "--exclude=.Rhistory"
               "--exclude=.juliahistory"
               "--delete-excluded")))

;; TODO seperate options
;; if verbose, print command that was called as well
(defn dry-run-flags [valargs]
  (if (-> valargs :options :dry-run)
    (let [home (System/Property "user.home")
          logfile (str "--log-file=" home "/rclonelog.txt")]
      (if (.exists (io/file logfile))
        (io/delete-file logfile))
      (assoc valargs :command
             (conj (:command valargs)  "--verbose" "--dry-run" logfile)))
    valargs))

(defn print-command [valargs]
  (let [cmd (:command valargs)]
    (pprint cmd))
  valargs)

(defn print-valargs [valargs]
  (pprint valargs)
  valargs)

(defn push-command [valargs]
  (-> valargs
      test-flag
      push-flags
      dry-run-flags
      add-action
      add-local
      add-remote))

(defn pull-command [valargs]
  (-> valargs
      test-flag
      dry-run-flags
      add-action
      add-remote
      add-local))

(defn form-command [valargs]
  (let [action (:action valargs)]
    (case action
      "push" (push-command valargs)
      "pull" (pull-command valargs))))


(defn run-command [valargs]
  (let [cmd (:command (form-command valargs))]
    (println (:out (apply sh cmd)))))

(defn run [args]
  (let [valargs (validate-args args)
        {:keys [exit-message ok? action]} valargs]
    (if exit-message
      (exit (if ok? 0 1) exit-message)
      (run-command valargs))))

(run *command-line-args*)
